#ifndef _PARTICLE_H_
#define _PARTICLE_H_

#include "../../Inc/Algorithm/RingBuffer.cginc"

#include "NebulaModifierDefine"

#include "ParticleCommon.cginc"
#include "EmitShape.compute"

void DoParticleEmitShape(uint3 id, inout FParticle cur, uint shapeIndex);
void OnInitParticle(uint3 id, inout FParticle particle);
void OnDeadParticle(uint3 id, uint idxInPool, inout FParticle particle);
void DoParticleEffectors(uint3 id, inout FParticle particle);
void DoUpdateSystem(uint3 id, uint3 GroupId, uint3 GroupThreadId, uint GroupIndex);
void DoOnTimer(uint3 id, uint3 GroupId, uint3 GroupThreadId, uint GroupIndex, float second);

RWStructuredBuffer<FParticle>	bfParticles;

RWByteAddressBuffer				bfFreeParticles;
RWByteAddressBuffer				bfCurAlives;
RWByteAddressBuffer				bfBackendAlives;

RWByteAddressBuffer				bfDispatchArg;
RWByteAddressBuffer				bfDrawArg;

groupshared int GroupRunParticleNumber = 0;

TtRawRingBuffer GetAllocator()
{
    TtRawRingBuffer Allocator;
    Allocator.RingBuffer = bfFreeParticles;
    Allocator.Capacity = AllocatorCapacity;
    return Allocator;
}

TtReadonlyRawArray GetCurrentAlives()
{
    TtReadonlyRawArray Alives;
    Alives.RawBuffer = bfCurAlives;
    Alives.Capacity = CurAliveCapacity;
    return Alives;
}

TtRawArray GetBackendAlives()
{
    TtRawArray Alives;
    Alives.RawBuffer = bfBackendAlives;
    Alives.Capacity = BackendAliveCapacity;
    return Alives;
}

uint GetParticleIndexByThreadID(uint id)
{
    TtReadonlyRawArray CurAlives = GetCurrentAlives();
    return CurAlives.GetValue(id.x);
}

void SpawnParticle(uint3 id, uint num, uint flags, float life)
{
    TtRawRingBuffer Allocator = GetAllocator();
    TtRawArray Alives = GetBackendAlives();
    
    //int SrcIndexId = Allocator.GetPopNumIndex(num);
    //int TarIndexId = Alives.GetPushNumIndex(num);
    for (uint i = 0; i < num; i++)
    {
        //int index = Allocator.GetValue(SrcIndexId + i);
        //Alives.SetValue(TarIndexId + i, index);
        int index = Allocator.Pop();
        Alives.Push(index);
		
        bfParticles[index].Life = life;
        bfParticles[index].Flags = flags;
		
        if (IsParticleEmitShape(bfParticles[index]))
        {
            uint shapeIndex = GetParticleData(bfParticles[index].Flags); // % (uint)EmitterShapes.Count;
            DoParticleEmitShape(id, bfParticles[index], shapeIndex);
        }

        bfParticles[index].Location += EmitterData.Location;
        OnInitParticle(id, bfParticles[index]);
    }
}

uint NebulaRoundup(uint num, uint width)
{
    return (num % width == 0) ? (num / width) : (num / width + 1);
}

[numthreads(DispatchX, DispatchY, DispatchZ)]
void CS_Particle_Update(uint3 id : SV_DispatchThreadID,
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex)
{
    if (OnTimer == 1)
    {
        DoOnTimer(id, GroupId, GroupThreadId, GroupIndex, ParticleStartSecond);
    }
    DoUpdateSystem(id, GroupId, GroupThreadId, GroupIndex);
	
    TtRawRingBuffer Allocator = GetAllocator();
    TtReadonlyRawArray CurAlives = GetCurrentAlives();
    TtRawArray BackendAlives = GetBackendAlives();
	
    GroupRunParticleNumber = 0;
	GroupMemoryBarrierWithGroupSync();
	
    int tmpCount;
    uint CountOfAlive = CurAlives.GetCount();
	if (id.x < CountOfAlive)
	{
        int idx = CurAlives.GetValue(id.x);
		bfParticles[idx].Life -= ParticleElapsedTime;

        if (bfParticles[idx].Life <= 0)
		{
            Allocator.Push(idx);
            OnDeadParticle(id, idx, bfParticles[idx]);
        }
		else
		{
            BackendAlives.Push(idx);
            DoParticleEffectors(id, bfParticles[idx]);
            
            bfParticles[idx].Location += bfParticles[idx].Velocity * ParticleElapsedTime;
        }
		InterlockedAdd(GroupRunParticleNumber, 1, tmpCount);
	}
	GroupMemoryBarrierWithGroupSync();
	
    InterlockedAdd(bfSystemData[0].TempData.x, GroupRunParticleNumber, tmpCount);
    if (tmpCount + GroupRunParticleNumber >= CountOfAlive)
    {
        bfCurAlives.Store(0, 0);
        uint num = BackendAlives.GetCount();
        SetIndirectDrawIndexArg(bfDrawArg, 0,
				Draw_IndexCountPerInstance,
				num,
				Draw_StartIndexLocation,
				Draw_BaseVertexLocation,
				Draw_StartInstanceLocation,
				0);
		
        if (num == 0)
        {
            num = 1;
        }
        num = NebulaRoundup(num, DispatchX);
        SetIndirectDispatchArg(bfDispatchArg, 0, uint3(num, 1, 1), 0);
    }
}

#include "NebulaModifier"

#ifndef USER_EMITSHAPE
void DoParticleEmitShape(uint3 id, inout FParticle particle, uint shapeIndex)
{

}
#endif

#ifndef USER_PARTICLE_INITIALIZE
void OnInitParticle(uint3 id, inout FParticle particle)
{

}
#endif

#ifndef USER_PARTICLE_FINALIZE
void OnDeadParticle(uint3 id, uint idxInPool, inout FParticle particle)
{

}
#endif

#ifndef USER_PARTICLE_DOEFFECTORS
void DoParticleEffectors(uint3 id, inout FParticle particle)
{

}
#endif

#ifndef USER_PARTICLE_UPDATESYS
void DoUpdateSystem(uint3 id, uint3 GroupId, uint3 GroupThreadId, uint GroupIndex)
{

}
#endif

#ifndef USER_PARTICLE_ONTIMER
void DoOnTimer(uint3 id, uint3 GroupId, uint3 GroupThreadId, uint GroupIndex, float second)
{

}
#endif

#endif//#ifndef _PARTICLE_H_